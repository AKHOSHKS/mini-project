<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="description"
   content="Gitless is an experimental version control system built on top of Git" />
  <title>Gitless</title>
  <link rel="stylesheet" type="text/css" href="css/reset.css" />
  <link rel="stylesheet" media="screen" href="css/grid960.css" />
  <link rel="stylesheet" type="text/css" href="css/type.css" />
  <link rel="stylesheet" type="text/css" href="css/helpers.css" />
  <link rel="stylesheet" type="text/css" href="css/custom.css" />
  <link rel="stylesheet" type="text/css"
   href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic" />
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create','UA-61756998-1','auto');ga('send','pageview',{'page':
  location.pathname+location.search+location.hash});
  </script>
  <script>
  $(function(){$('a').click(function(e){e.preventDefault();var href=$(this).attr('href');
  function load(){document.location=href};ga('send','event','link','click',
  href,{'hitCallback':load});setTimeout(load,1000);})});
  </script>
</head>

<body>
  <div id="ribbon">
  <a href="https://github.com/sdg-mit/gitless">
    <img style="position: absolute; top: 0; right: 0; border: 0;"
     src="fork-me.png" alt="Fork me on GitHub">
  </a>
  </div>
  <div id="container">

    <div id="header" class="full top_margin_20">
     <img src="gitless-banner.png" alt="gitless" width="600" />
    </div>

    <div id="sidebar" class="third news">  
      <!-- Begin Download -->
      <h1><span>Download</span></h1>
      <div>
        <ul style="margin-top: 2em">
          <li>
            <a href="https://github.com/sdg-mit/gitless/releases/download/v0.7/gl-v0.7-darwin-x86_64.tar.gz">
            Mac OS X Binary (.tar.gz)
            </a>
          </li>
          <li>
            <a href="https://github.com/sdg-mit/gitless/releases/download/v0.7/gl-v0.7-linux-x86_64.tar.gz">
            Linux Binary (.tar.gz)
            </a>
          </li>
          <li>
            <a href="https://github.com/sdg-mit/gitless/archive/v0.7.tar.gz">
            Source Code (.tar.gz)
            </a>
          </li>
        </ul>

        <p>
        For installation instructions see the
        <a href="https://github.com/sdg-mit/gitless/blob/master/README.md#install">
        README
        </a>
        file.
        After installation, you should be able to execute the <code>gl</code>
        command. The current Gitless version is 0.7 which was released on
        4/2015 (<a href="https://github.com/sdg-mit/gitless/blob/master/RELEASE_NOTES.md">release notes</a>).
        </p>

      </div>
      <!-- End Download -->
    </div>
    <!-- Begin Main -->
    <div id="main" class="twothird">
      <h1>About Gitless</h1>
      <p>
      Gitless is an experimental version control system built on top of Git.
      Many people complain that Git is hard to use. We think the problem lies
      deeper than the user interface, in the concepts underlying Git. Gitless
      is an experiment to see what happens if you put a simple veneer on an app
      that changes the underlying concepts. Because Gitless is implemented on
      top of Git (could be considered what Git pros call a "porcelain" of Git),
      you can always fall back on Git. And of course your coworkers you share a
      repo with need never know that you're not a Git aficionado.
      </p>

      <p>
      Check out the <a href="#documentation">documentation</a> to get started.
      If you are a novice user that never used any version control system the
      documentation should be enough to get you started. If you are a Git pro
      looking to see what's different from your beloved Git you'll be able to
      spot the differences by glancing through the
      <a href="#vs">Gitless vs. Git</a> section.
      </p>
    </div>
    <!-- End Main -->

    <!-- Begin Documentation -->
    <div class="twothird">
      <a id="documentation"><h1>Documentation</h1></a>

      <!-- Begin Documentation/Commands -->

      <h2>Commands</h2>
        <p>
        The link will take you to the point in the guide in which the
        command is introduced
        </p>
        <ul>
          <li>
            <code><a href="#gl-init">gl init</a></code>
            - create an empty repo or create one from an existing remote
              repo
          </li>
          <li>
            <code><a href="#gl-status">gl status</a></code>
            - show status of the repo
          </li>
          <li>
            <code><a href="#gl-track">gl track</a></code>
            - start tracking changes to files
          </li>
          <li>
            <code><a href="#gl-untrack">gl untrack</a></code>
            - stop tracking changes to files
          </li>
          <li>
            <code><a href="#gl-diff">gl diff</a></code>
            - show changes to files
          <li>
            <code><a href="#gl-commit">gl commit</a></code>
            - record changes in the local repo
          </li>
          <li>
            <code><a href="#gl-checkout">gl checkout</a></code>
            - checkout committed versions of files
          </li>
          <li>
            <code><a href="#gl-history">gl history</a></code>
            - show commit history
          </li>
          <li>
            <code><a href="#gl-branch">gl branch</a></code>
            - list, create, edit or delete branches
          </li>
          <li>
            <code><a href="#gl-switch">gl switch</a></code>
            - switch branches
          </li>
          <li>
            <code><a href="#gl-merge">gl merge</a></code>
            - merge the divergent changes of one branch onto another
          </li>
          <li>
            <code><a href="#gl-rebase">gl rebase</a></code>
            - rebase the divergent changes of one branch onto another
          </li>
          <li>
            <code><a href="#gl-resolve">gl resolve</a></code>
            -  mark files with conflicts as resolved
          </li>
          <li>
            <code><a href="#gl-publish">gl publish</a></code>
            - publish commits upstream
          </li>
          <li>
            <code><a href="#gl-remote">gl remote</a></code>
            - list, create, edit or delete remotes
          </li>
        </ul>
      <!-- End Documentation/Commands -->

      <!-- Begin Documentation/Guide -->
      <h2>Guide</h2>

      <a id="repository"><h3>Repository</h3></a>
      <p>
      Say you are in directory <code>foo</code> and you want turn it into a
      local repository. You do this with the
      <code><a id="gl-init">gl init</a></code> command. This will transform
      the current working directory into an empty Gitless's repository and you
      are now ready to start recording changes to files in <code>foo</code>.
      </p>
      <pre>
      <code>
      $ mdkir foo
      $ cd foo/
      $ gl init
      # Local repo created in '/MyFiles/foo'
      </code>
      </pre>
      <p>
      In most cases, there's probably already some existing repository that you
      want to start working on instead of creating an empty repository (maybe
      you just created a GitHub repo you want to now start using). To make a
      local clone of a remote repository you can give the url of the repository
      to the same <code>gl init</code> command. 
      </p>
      <pre>
      <code>
      $ mkdir experiment
      $ cd experiment/
      $ gl init https://github.com/spderosso/experiment
      # Local repo created in '/MyFiles/foo'
      # Initialized from remote 'https://github.com/spderosso/experiment'
      </code>
      </pre>
      <a id="file"><h3>File</h3></a>
      <p>
       A file in Gitless is one of the following: a
      "Tracked File," an "Untracked File" or an "Ignored File."
      </p>

      <p>
      <em>Tracked File.</em>
      A tracked file is a file whose changes Gitless will automatically detect.
      Tracked files are automatically considered for commit if they are
      modified. These will appear under the "Tracked files with modifications"
      section of the <code><a id="gl-status">gl status</a></code>
      command.
      </p>
      <p>
      <em>Untracked File.</em>
      Conversely, an untracked file is a file whose changes Gitless will not
      automatically detect and is listed under the "Untracked files" section of
      the <code>gl status</code> command. These are not automatically considered
      for commit.
      </p>
      <p>
      <em>Ignored File.</em>
      An ignored file is a file that is completely ignored by Gitless. These won't
      even appear in the output of the <code>gl status</code> command.
      </p>
      <p>
      An example output of the status command
      (<code>foo.py</code> is a tracked file
      with modifications, <code>.gitignore</code> is an unmodified tracked file,
      <code>bar.py</code> is an untracked file and <code>foo.py~</code> is an
      ignored file):
      </p>
      <pre>
      <code>
      $ ls
      bar.py  foo.py  foo.py~ .gitignore
      $ gl status
      # On branch master, repo-directory //
      #
      # Tracked files with modifications:
      #   (these will be automatically considered for commit)
      #   (use gl untrack &lt;f&gt; if you don't want to track changes to file f)
      #   (if file f was committed before, use gl checkout &lt;f&gt; to discard local changes)
      #
      #     foo.py
      #
      #
      # Untracked files:
      #   (these won't be considered for commit)
      #   (use gl track &lt;f&gt; if you want to track changes to file f)
      #
      #     bar.py
      </code>
      </pre>

      <p>
      Now, how do files move between these three different <em>disjoint</em>
      states?
      </p>
      <p>
      A file is ignored if it's matched by the ignore specification described in
      the <code>.gitignore</code> file (which is usually present in the root of
      the repository).
      In the example above,
      there is a <code>.gitignore</code> file whose content is '*~'; since
      <code>foo.py~</code> is matched by that pattern it's therefore an
      ignored file.
      </p>
      <p>
      A new file that is not matched by the ignore spec is initially an untracked
      file. If you want to make it a tracked file you can do so with the
      <code><a id="gl-track">gl track</a></code> command. A file
      that has a commited version in the repository is
      automatically a tracked file. You can stop tracking changes to a tracked file
      with the <code><a id="gl-untrack">gl untrack</a></code> command.
      You can always revert a file back to some previous version with the
      <code><a id="gl-checkout">gl checkout</a></code> command, and
      <code><a id="gl-diff">gl diff</a></code> can be used to see the
      difference between the working and comitted versions of files.
      </p>
      <p>
      As previously said, all tracked and modified files are automatically
      considered for commit. Doing
      <code><a id="gl-commit">gl commit</a></code> will commit
      these changes (once you provide a
      commit message). The commit command accepts a bunch of flags to make
      selecting a subset of files to commit super easy:
      </p>
      <ul>
        <li>
        Doing <code>gl commit f1 f2</code> will only commit files
        <code>f1</code> and <code>f2</code>. If they are untracked it will make them tracked.
        Since only those files specified will be commited this is a handy way
        of leaving other tracked modified files out of the commit.
        </li>
        <li>
        But what if you want to commit all of the tracked modified files but
        leave one of them out? Having to list them all seems annoying. You
        can do <code>gl commit -e f</code> to exclude that file
        <code>f</code> you don't want to commit right now.
        </li>
        <li>
        Additionally you can use the <code>-i</code> flag to include untracked
        files in the commit set (it will make them tracked).
        </li>
      </ul>

      <a id="branch"><h3>Branch</h3></a>
      <p>
      A branch is an independent line of development. Each branch has its own
      history (which you can look at with the
      <a id="gl-history">gl history</a>
      command). Any changes to
      existing files or new files you create on a branch will not be present on
      the other branch when you switch branches.
      </p>
      <p>A new branch can be created with the
      <a id="gl-branch">gl branch</a>
      command. To switch to another branch you use the
      <a id="gl-switch">gl switch</a> command.
      </p>
      <pre>
      <code>
      $ gl branch -c my-branch
      # Created new branch my-branch
      $ gl switch my-branch
      # Switched to branch my-branch
      </code>
      </pre>
      <p>
      To list all available branches:
      </p>
      <pre>
      <code>
      $ gl branch
      # List of branches:
      #   (do gl branch &lt;b&gt; to create branch b)
      #   (do gl branch -d &lt;b&gt; to delete branch b)
      #   (do gl switch &lt;b&gt; to switch to branch b)
      #   (* = current branch)
      #
      #     * master
      #       my-branch
      </code>
      </pre>

      <p>
      Eventually what will happen is that branches will end up having divergent
      changes. There are two ways of bringing changes from one branch onto the
      current branch: merge or rebase. (If you have no idea what merge or rebase
      mean, you can take look at Git's documentation.) (This will change
      in Gitless 1.0 ---which will be released sometime soon.)
      </p>

      <p>
      For merging the changes in <code>my-branch</code> onto the current branch you do
      <code><a id="gl-merge">gl merge my-branch</a></code>,
      for rebasing the current branch using as a base <code>my-branch</code> you do
      <code><a id="gl-rebase">gl rebase my-branch</a></code>.
      </p>
      <p>
      During this process conflicts could occur. If so, the <code>gl status</code> command will change
      accordingly to indicate the files in conflict. Once you edit those files in
      conflict you mark them as resolved with
      <code><a id="gl-resolve">gl resolve</a></code> (passing the files to mark as input). Once all
      conflicts have been resolved
      you do <code>gl commit</code> to commit the merge commit in
      case of a merge or to continue applying any remaining commits in case of
      a rebase.
      </p>
      <p>
      Of course, it is also possible to merge or rebase changes from remote
      branches, or branches that are in remote repositories (not in your local
      repository). Let's say "experiment" stands for the remote at 
      https://github.com/spderosso/experiment and that master is a branch
      present in that remote repository. If so, doing
      <code>gl merge experiment/master</code>
      would merge any changes in that remote branch that are not present in your
      local current branch. A very common use case is to have a remote
      repository you always get changes from and send changes to it so that
      others can retrieve them. To make this more easy, a branch can have an
      "upstream branch". If a branch has an upstream associated with it, then
      <code>gl rebase</code> or <code>gl merge</code> can be used as shorthands for
      <code>gl {rebase, merge} upstream_remote/upstream_branch</code>. To set an
      upstream branch for the current branch use
      <code>gl branch -su upstream_remote/upstream_branch</code>.
      </p>
      <p>
      To publish your changes to this upstream branch you can do
      <code><a id="gl-publish">gl publish</a></code>. If the upstream
      branch doesn't exist in the remote, then the branch will be created in the
      remote after the publish.
      </p>
      <p>
      When you create a local repository from a remote (by passing a url as
      input to the <code>gl init</code> command), all branches are
      automatically configured to have as upstream their remote counterpart.
      </p>
  
      <a id="remote"><h3>Remote</h3></a>
      <p>
      You can always use the direct url to
      bring in changes to your local repository from a remote repository but
      remembering all those long urls can be annoying. So an easier way is to
      add that repository as a "remote" with the
      <code><a id="gl-remote">gl remote</a></code> command.
      For example, let's add my GitHub experiment repository as a remote:
      </p>
      <pre>
      <code>
      $ gl remote -c experiment https://github.com/spderosso/experiment
      # Remote experiment mapping to https://github.com/spderosso/experiment created successfully
      #   (to list existing remotes do gl remote)
      #   (to remove experiment do gl remote -d experiment)
      </code>
      </pre>
      <p>
      And then you can use experiment/branch as a shorthand for referring to a
      branch in the experiment repository.
      </p>
      <!-- End Documentation/Guide -->
    </div>
    <!-- End Documentation -->

    <!-- Begin Versus -->
    <div class="twothird">
      <a id="vs"><h1>Gitless vs. Git</h1></a>
      <p>Gitless on the left, Git on the right.</p>

      <!-- Begin Versus/Changes -->
      <h2>Recording Changes to the Repository</h2>
      <p>There's no staging area in Gitless. This, coupled with a flexible
      commit command makes recording changes to the repository very
      straightforward:
      </p>

      <div class="vs">
        <pre class="gl">
        <code>
        <span class="task">Commit all modified tracked files</span>
        $ gl commit
        ...
        <span class="comment">The default set of files to be commited are
        all modified tracked files</span>

        <span class="task">Leave some modified tracked files (`foo`, `bar`)
        out of the commit</span>
        $ gl commit -e foo bar
        ...
        <span class="comment">-e/--exclude excludes files from the
        default set of files to be commited</span>




        <span class="task">Include some untracked files in the
        commit</span>
        $ gl commit -i foo2 bar2
        ...
        <span class="comment">-i/--include includes files to the
        default set of files to be commited</span>
        <span class="comment">-i and -e can be combined together</span>

        <span class="task">Commit only some of the modified tracked
        files</span>
        $ gl commit foo3 bar3
        ...
        <span class="comment">Giving files as input to the commit command
        restricts the set of files to be committed to only
        the specified ones</span>

        <span class="task">Commit only some of the modified tracked or
        untracked files</span>
        $ gl commit foo3 bar3 foo4
        ...
        </code>
        </pre>
        <pre class="git">
        <code>
        <span class="task">Commit all modified tracked files</span>
        $ git commit -a
        ...
        <span class="comment">-a/--all automatically
        stages files that have been modified or deleted</span>

        <span class="task">Leave some modified tracked files (`foo`, `bar`)
        out of the commit</span>
        $ git add <span class="comment">(all files you want to commit minus foo bar)</span>
        $ git commit






        <span class="task">Include some untracked files in the
        commit</span>
        $ git add foo2 bar2  <span class="comment">(+ modified tracked files you want to commit)</span>
        $ git commit
        ...



        <span class="task">Commit only some of the modified tracked
        files</span>
        $ git commit foo3 bar3
        ...




        <span class="task">Commit only some of the modified tracked or
        untracked files</span>
        $ git commit foo3 bar3 foo4
        error: pathspec 'foo4' did not match any file(s) known to git.
        <span class="comment">...hmm ok... </span>
        $ git add foo4
        $ git commit foo3 bar3 foo4
        ...
        </code>
        </pre>
        <div style="clear:both"></div>
      </div>
      <p>Also, you can change the classification of any file to tracked,
      untracked or ignored, it doesn't matter whether the file exists at head
      or not:
      </p>
      <div class="vs">
        <pre class="gl">
        <code>
        <span class="comment">Say we have committed file `foo` with
        modifications</span>
        $ gl status
        # ...
        # Tracked files with modifications:
        # ...
        #   foo
        # ...

        <span class="task">Stop tracking changes to `foo`</span>
        $ gl untrack foo
        # File foo is now an untracked file
        <span class="comment">Now `foo` won't be automatically considered
        for commit</span>
        $ gl status
        # ...
        # Untracked files:
        # ...
        #   foo (exists at head)
        # ...

        <span class="task">Start tracking changes to `foo` again</span>
        $ gl track foo
        # File foo is now a tracked file
        <span class="comment">Now `foo` will be automatically considered
        for commit</span>
        $ gl status
        # ...
        # Tracked files with modifications:
        # ...
        #   foo (exists at head)
        # ...
        </code>
        </pre>
        <pre class="git">
        <code>
        <span class="comment">Say we have committed file `foo` with
        modifications</span>
        $ git status
        # ...
        # Changes not staged for commit:
        # ...
        #   modified: foo
        # ...

        <span class="task">Stop tracking changes to `foo`</span>
        <span class="comment">No way to do this, if you want to prevent accidental
        commiting of the file you can always do `git add` of all the files
        but `foo` everytime you do a commit. Alternatively, you can ignore the
        file by marking it as assumed unchanged</span>
        $ git update-index --assume-unchanged foo
        <span class="comment">Now the file behaves as if it were ignored</span>
        $ git status
        ...
        <span class="comment">`foo` won't appear listed in status</span>


        <span class="task">Start tracking changes to `foo` again</span>
        $ git update-index --no-assume-unchanged foo
        $ git status
        # ...
        # Changes not staged for commit:
        # ...
        #   modified: foo
        # ...
        </code>
        </pre>
        <div style="clear:both"></div>
      </div>
      <!-- End Versus/Changes -->

      <!-- Begin Versus/Branching -->
      <h2>Branching</h2>
      <p>
      The main thing to understand is that in Gitless a branch is a completely
      independent line of development. Each branch keeps its working version
      of files separate from each other. Whenever you switch to a different
      branch, the contents of your working directory are saved, and the ones
      corresponding to the branch you are switching to are retrieved. The
      classifications of files are also saved (i.e., a file can
      be untracked on some branch but tracked on another and Gitless will
      remember this):
      </p>
      <div class="vs">
        <pre class="gl">
        <code>
        <span class="comment">Say we have committed file `foo` with
        modifications</span>
        $ gl status
        # ...
        # Tracked files with modifications:
        # ...
        #   foo
        # ...

        <span class="task">Create new branch `develop`</span>
        $ gl branch -c develop
        # Created new branch "develop"

        <span class="task">Switch to `develop`</span>
        $ gl switch develop
        # Switched to branch develop
        $ gl status
        # ...
        # Tracked files with modifications:
        # ... no changes to foo here


        <span class="task">Switch back to `master`</span>
        $ gl switch master
        # Switched to branch master
        $ gl status
        # ...
        # Tracked files with modifications:
        # ...
        #   foo
        # ...

        <span class="comment">If you want the uncommitted changes to follow
        you into the new branch you can use the
        -mo/--move-over flag to move over the changes
        in the current branch to the destination branch</span>
        </code>
        </pre>
        <pre class="git">
        <code>
        <span class="comment">Say we have committed file `foo` with
        modifications</span>
        $ git status
        # ...
        # Changes not staged for commit:
        # ...
        #   modified: foo
        # ...

        <span class="task">Create new branch `develop`</span>
        $ git branch develop


        <span class="task">Switch to `develop`</span>
        $ git checkout develop
        $ git status
        # ...
        # Changes not staged for commit:
        # ...
        #   modified: foo
        # ...

        <span class="task">Switch back to `master`</span>
        $ git checkout master
        # ...
        # Changes not staged for commit:
        # ...
        #   modified: foo
        # ...
        </code>
        </pre>
        <div style="clear:both"></div>
      </div>
      <p>
      This means that in Gitless you don't have to worry about uncommitted
      changes conflicting with the changes in the destination branch:
      </p>
      <div class="vs">
        <pre class="gl">
        <code>
        <span class="comment">Say we have uncomitted changes to `foo`
        which conflict with the state of `foo` in
        branch `develop`</span>

        <span class="task">Switch to `develop`</span>
        $ gl switch develop
        # Switched to branch develop
        </code>
        </pre>
        <pre class="git">
        <code>
        <span class="comment">Say we have uncomitted changes to `foo`
        which conflict with the state of `foo` in
        branch `develop`</span>

        <span class="task">Switch to `develop`</span>
        $ git checkout develop
        error: Your local changes to the following files
        would be overwritten by checkout:
             foo
        Please, commit your changes or stash them before
        you can switch branches.
        Aborting
        $ git stash
        Saved working directory and index state WIP on
        master: fbe3b8c ...
        HEAD is now at fbe3b8c ...
        $ git checkout develop
        Switched to branch 'develop'
        </code>
        </pre>
        <div style="clear:both"></div>
      </div>
      <p>
      And if you are in the middle of a rebase/merge and you want to put aside
      the conflict resolution for later, you can. The conflict will be there
      when you switch back:
      </p>
      <p>
      (Not yet implemented, coming soon)
      </p>
      <div class="vs">
        <pre class="gl">
        <code>
        $ gl rebase develop
        # There are conflicts you need to resolve
        $ gl status
        # On branch master, repo-directory //
        #
        # You are in the middle of a rebase; all
        # conflicts must be resolved before
        # commiting
        # ...
        # Tracked files with modifications:
        #      ...
        #     foo (with conflicts)
        #
        ...







        <span class="task">Switch to `bugfix`</span>
        $ gl switch bugfix
        # Switched to branch bugfix
        <span class="comment">No conflicts here</span>















        <span class="task">Switch back to `develop`</span>
        $ gl switch develop
        # Switched to branch develop
        $ gl status
        # On branch master, repo-directory //
        #
        # You are in the middle of a rebase; all
        # conflicts must be resolved before
        # commiting
        # ...
        # Tracked files with modifications:
        #     ...
        #     foo (with conflicts)
        #
        ...
        </code>
        </pre>
        <pre class="git">
        <code>
        $ git rebase develop
        First, rewinding head to replay your work on top of it...
        Applying: this commit should trigger a conflict
        Using index info to reconstruct a base tree...
        M foo
        Falling back to patching base and 3-way merge...
        Auto-merging foo
        CONFLICT (content): Merge conflict in foo
        Failed to merge in the changes.
        Patch failed at 0001 foo conflict
        The copy of the patch that failed is found in:
           ...
        $ git status
        rebase in progress; onto 989269e
        You are currently rebasing branch 'master' on '989269e'.
          ...
        Unmerged paths:
          ...
          both modified:   foo
        ...

        <span class="task">Switch to `bugfix`</span>
        $ git checkout bugfix
        foo: needs merge
        error: you need to resolve your current index first
        <span class="comment">Maybe stash works?</span>
        $ git stash
        foo: needs merge
        foo: needs merge
        foo: unmerged (0b3c542edb2e9e8ff801c669d7a5f2d78fe2678b)
        foo: unmerged (94421333de34e32405f632d0f7b63b39c8930776)
        foo: unmerged (eb97dba229aab53fe5f231e60491dd2a7cb09703)
        fatal: git-write-tree: error building trees
        Cannot save the current index state
        <span class="comment"> ...hmm..ok...</span>
        $ <span class="comment">save all the changes to files somewhere else</span>
        $ git rebase --abort
        $ git checkout bugfix
        Switched to branch 'bugfix'

        <span class="task">Switch back to `develop`</span>
        $ git checkout develop
        $ git status
        ...
        <span class="comment">We aborted the rebase to be able to
        switch branches, so there's nothing here now</span>
        $ git rebase develop
        ... <span class="comment">same conflict as before</span>
        $ <span class="comment">Copy back the changes we saved</span>
        </code>
        </pre>
        <div style="clear:both"></div>
      </div>
      <!-- End Versus/Branching -->

      <!-- Begin Versus/Syncing -->
      <h2>Syncing with Other Repositories</h2>
      <p>
      Syncing with other repositories in Gitless works quite similar to
      Git:
      </p>
      <div class="vs">
        <pre class="gl">
        <code>
        <span class="task">Configure a new remote `experiment`</span>
        $ gl remote -c experiment
        https://github.com/spderosso/experiment
        # Remote experiment mapping to
        # https://github.com/spderosso/experiment
        # created successfully
        #   (to list existing remotes do gl remote)
        #   (to remove experiment do gl remote -d experiment)

        <span class="task">Download and apply changes from a branch
        in `experiment`</span>
        $ gl rebase experiment/master
        # Rebase succeeded
        <span class="comment">If you instead want to merge the changes, you
        can do `gl merge experiment/master`</span>

        <span class="comment">You can also set an upstream for the
        current branch</span>
        $ gl branch -su experiment/master
        # Current branch master set to track
        # experiment/master
        $ gl rebase
        # No src branch specified, defaulted to getting
        # changes from upstream branch experiment/master

        <span class="task">Send changes to the remote</span>
        $ gl publish
        # No src branch specified, defaulted to sending
        # changes to upstream branch experiment/master
        # Publish succeeded
        <span class="comment">Only the changes in the current branch
        are uploaded</span>
        </code>
        </pre>
        <pre class="git">
        <code>
        <span class="task">Configure a new remote `experiment`</span>
        $ git remote add experiment
        https://github.com/spderosso/experiment






        <span class="task">Download and apply changes from a branch
        in `experiment`</span>
        $ git pull experiment/master
        ...
        <span class="comment">If you instead want to rebase the
        changes, you can do `git pull --rebase experiment/master`</span>

        <span class="comment">You can also set an upstream for the
        current branch</span>
        $ gl branch --set-upstream master experiment/master
        $ git pull
        ...




        <span class="task">Send changes to the remote</span>
        $ git push
        <span class="comment">What happens when you do a push depends on
        the value of the `push.default` config variable</span>
        </code>
        </pre>
        <div style="clear:both"></div>
      </div>
      <!-- End Versus/Syncing -->

    </div>
    <!-- End Versus -->

    <!-- Begin Community -->
    <div class="twothird">
      <h1>Community</h1>
      <p>
      Questions or comments to the Gitless's community can be sent to the
      <a href="https://groups.google.com/forum/#!forum/gl-users">Gitless
      users mailing list</a> on Google groups. For bug reports or feature
      requests you can
      <a href="http://github.com/sdg-mit/gitless/issues">create an issue
      on GitHub</a>.
      </p>
      <p>
      If you would like to contribute to the development of Gitless, you can
      read more about how you can help
      <a href="http://github.com/sdg-mit/gitless/blob/master/README.md">here</a>.
      </p>
    </div>
    <!-- End Community -->

    <!-- Begin Footer -->
    <div id="footer" class="full top_margin_20">
      <p>
      &copy; 2015 Santiago Perez De Rosso.
      </p>
      <p>
      <em>Acknowledgements.</em> Gitless is part of a research project exploring
      concept design. This research is part of a collaboration between MIT and
      SUTD (the Singapore University of Technology and Design), and is funded by
      a grant from SUTD's International Design Center.
      </p>
      <p>
      <em>Privacy policy.</em> This website, like a gazillion other websites,
      uses Google Analytics. We use the information (anonymously) collected by
      Google Analytics to track the number of visits, downloads and other 
      relevant information.
      If you want, you can easily opt-out of Google Analytics tracking
      software (there are many ways to do so; find them online).
      </p>
    </div>
    <!-- End Footer -->
  </div>
</body>
</html>
