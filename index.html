<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>Gitless</title>
  <link rel="stylesheet" type="text/css" href="css/reset.css"/>
  <link rel="stylesheet" media="screen" href="css/grid960.css" />
  <link rel="stylesheet" type="text/css" href="css/type.css" />
  <link rel="stylesheet" type="text/css" href="css/helpers.css" />
  <link rel="stylesheet" type="text/css" href="css/custom.css"/>
  <link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
</head>

<body>

  <div id="container" >

    <div id="header" class="full top_margin_20">
       <img src="gitless-banner.png" alt="gitless" width="600px"/>
    </div>

    <div id="sidebar" class="third news">  
      <h2><span>Download</span></h2>
      <div>
        <p>
        You need to have Python and Git installed (1.7.12+). The easiest way
        to download (and install) Gitless is through the
        <a href="http://pip.readthedocs.org/en/latest/installing.html">
        Python Package Index (pip)</a>. Once you have <code>pip</code> just do:
        </p>
        <pre>
        pip install gitless
        </pre>
        <p>
        You should now be able to start executing the <code>gl</code> command.
        The current Gitless version is 0.6.2.
        </p>
        <p>
        (User friendly installer coming soon.)
        </p>
      </div>
    </div>
    <!-- Begin Main -->
    <div id="main" class="twothird">
      <h2>About Gitless</h2>
      <p>
      Gitless is an experimental version control system built on top of Git.
      Many people complain that Git is hard to use. We think the problem lies
      deeper than the user interface, in the concepts underlying Git. Gitless
      is an experiment to see what happens if you put a simple veneer on an app
      that changes the underlying concepts. Because Gitless is implemented on
      top of Git (could be considered what Git pros call a 'porcelain' of Git),
      you can always fall back on Git. And of course your coworkers you share a
      repo with need never know that you're not a Git aficionado.
      </p>

      <p>
      Check out the documentation page to get started. If you are a novice user
      that never used any version control system the documentation
      should be enough to get you started. If you are a Git pro looking to see
      what's different from your beloved Git you'll be able to spot the
      differences by glancing through the documentation.
      </p>
    </div>
    <!-- End Main -->

    <!-- Begin Documentation -->
    <div class="twothird">
      <h2>Documentation</h2>

      <!-- Begin Documentation/Commands -->

      <h3>Commands</h3>
        <p>
        (link will take you to the point in the guide in which the
        command is introduced)
        </p>
        <ul>
          <li><a href="#gl-init"><pre class="inline">gl init</pre></a></li>
          <li><a href="#gl-status"><pre class="inline">gl status</pre></a></li>
          <li><a href="#gl-track"><pre class="inline">gl track</pre></a></li>
          <li><a href="#gl-untrack"><pre class="inline">gl untrack</pre></a></li>
          <li><a href="#gl-commit"><pre class="inline">gl commit</pre></a></li>
          <li><a href="#gl-checkout"><pre class="inline">gl checkout</pre></a></li>
          <li><a href="#gl-history"><pre class="inline">gl history</pre></a></li>
          <li><a href="#gl-branch"><pre class="inline">gl branch</pre></a></li>
          <li><a href="#gl-merge"><pre class="inline">gl merge</pre></a></li>
          <li><a href="#gl-rebase"><pre class="inline">gl rebase</pre></a></li>
          <li><a href="#gl-resolve"><pre class="inline">gl resolve</pre></a></li>
          <li><a href="#gl-publish"><pre class="inline">gl publish</pre></a></li>
          <li><a href="#gl-remote"><pre class="inline">gl remote</pre></a></li>
        </ul>
      <!-- End Documentation/Commands -->

      <!-- Begin Documentation/Guide -->
      <h3>Guide</h3>

      <a name="repository"><h4>Repository</h4></a>
      <p>
      Say you are in a directory <code>foo</code> and you want create a local
      repository. You do this with the <code><a name="gl-init">gl init</a></code>
      command. This will transform the current working directory into an empty
      Gitless's repository and you are now ready to start recording changes to
      files in <code>foo</code> and potentially sharing these changes with
      the rest of the world in the future.
      </p>
      <pre>
      $ mdkir foo
      $ cd foo/
      $ gl init
      # Local repo created in '/MyFiles/foo'
      </pre>
      <p>
      In most cases, there's probably already some existing repository that you
      want to start working on instead of creating an empty repository (maybe
      you just created a Github repo you want to now start using). You can
      do this with the <code>gl init</code> command as well by specifying the
      url of the repository. This makes a local clone of the remote repository.
      </p>
      <pre>
      $ mkdir experiment
      $ cd experiment/
      $ gl init https://github.com/spderosso/experiment.git
      # Initialized from remote
      # 'https://github.com/spderosso/experiment.git'
      </pre>
      </p>
      <a name="file"><h4>File</h4></a>
      <p>
       A file in Gitless is one of the following: a
      "Tracked File," an "Untracked File" or an "Ignored File."
      </p>

      <p>
      <b>Tracked File</b>
      A tracked file is a file whose changes Gitless will automatically detect.
      Tracked files are automatically considered for commit if they are
      modified. These will appear under the "Tracked files with modifications"
      section of the <code><a name="gl-status">gl status</a></code>
      command.
      </p>
      <p>
      <b>Untracked File</b>
      Conversely, an untracked file is a file whose changes Gitless will not
      automatically detect and is listed under the "Untracked files" section of
      the <code>gl status</code> command. These are not automatically considered
      for commit.
      </p>
      <p>
      <b>Ignored File</b>
      An ignored file is a file that is completely ignored by Gitless. These won't
      even appear in the output of the <code>gl status</code> command.
      </p>
      <p>
      An example of the output of the status command
      (<code>foo.py</code> is a tracked file
      with modifications, <code>.gitignore</code> is an unmodified tracked file,
      <code>bar.py</code> is an untracked file and <code>foo.py~</code> is an
      ignored file):
      </p>
      <pre>
      $ ls
      bar.py  foo.py  foo.py~ .gitignore
      $ gl status
      # On branch master, repo-directory //
      #
      # Tracked files with modifications:
      #   (these will be automatically considered for commit)
      #   (use gl untrack &lt;f&gt; if you don't want to track changes
      #    to file f)
      #   (if file f was committed before, use gl checkout &lt;f&gt;
      #    to discard local changes)
      #
      #     foo.py
      #
      #
      # Untracked files:
      #   (these won't be considered for commit)
      #   (use gl track &lt;f&gt; if you want to track changes to file f)
      #
      #     bar.py
      </pre>

      <p>
      Now, how do files move between these three different <em>disjoint</em>
      states?
      </p>
      <p>
      A file is ignored if it's matched by the ignore specification described by
      the <code>.gitignore</code> file in its directory or by any
      <code>.gitignore</code> file of its parent directories. In the example above,
      there is a <code>.gitignore</code> file whose content is '*~'; since
      <code>foo.py~</code> is matched by that pattern it's therefore an ignored file.
      </p>
      <p>
      A new file that is not matched by the ignore spec is initially an untracked
      file. If you want to make it a tracked file you can do so with the
      <code><a name="gl-track">gl track</a></code> command. A file
      that has a commited version in the repository is
      automatically a tracked file. You can stop tracking changes to a tracked file
      with the <code><a name="gl-untrack">gl untrack</a></code> command.
      You can always revert a file back to some previous version with the
      <code><a name="gl-checkout">gl checkout</a></code> command.
      </p>
      <p>
      As previously said, all tracked and modified files are automatically
      considered for commit. Which means that doing
      <code><a name="gl-commit">gl commit</a></code> will commit
      them (once you provide a
      commit message). The commit command accepts a bunch of flags to make
      selecting a subset of files to commit super easy:
      <ul>
        <li>
        Doing <code>gl commit f1 f2</code> will only commit files
        <code>f1</code> and <code>f2</code>. If they are untracked it will make them tracked.
        Since only those files specified will be commited this is a handy way
        of leaving other tracked modified files out of the commit.
        </li>
        <li>
        But what if you want to commit all of the tracked modified files but
        leave one of them out? Having to list them all seems annoying. You
        can do <code>gl commit -exc f</code> to exclude that file
        <code>f</code> you don't want to commit right now.
        </li>
        <li>
        Additionally you can use the <code>-inc</code> flag to include untracked
        files in the commit set (it will make them tracked).
        </li>
      </ul>
      </p>

      <a name="branch"><h4>Branch</h4></a>
      <p>
      A branch is an independent line of development. Each branch has its own
      history (which you can look at with the
      <a name="gl-history">gl history</a>
      command). Any changes to
      existing files or new files you create on a branch will not be present on
      the other branch when you switch branches.
      </p>
      <p>A new branch can be created with the
      <a name="gl-branch">gl branch</a>
      command. Once created you will be automatically switched to that branch.
      </p>
      <pre>
      $ gl branch my-branch
      # Created new branch my-branch
      # Switched to branch my-branch
      </pre>
      <p>
      If you want to switch to another existing branch called master you can do:
      </p>
      <pre>
      $ gl branch master
      # Switched to branch master
      </pre>
      <p>
      So, in summary <code>gl branch name</code> switches to branch
      <code>name</code> and it creates that branch if it doesn't exist. To list all available
      branches:
      </p>
      <pre>
      $ gl branch
      # List of branches:
      #   (do gl branch &lt;b&gt; to create or switch to branch b)
      #   (do gl branch -d &lt;b&gt; to delete branch b)
      #   (do gl branch -su &lt;upstream&gt; to set an upstream for the current branch)
      #   (* = current branch)
      #
      #     * master
      #       my-branch
      </pre>

      <p>
      Eventually what will happen is that branches will end up having divergent
      changes. There are two ways of bringing changes from one branch onto the
      current branch: merge or rebase. (If you have no idea what merge or rebase
      mean, you can take look at Git's documentation.) (This will change
      in Gitless 1.0 -- which will be released sometime soon.)
      </p>

      <p>
      For merging the changes in <code>my-branch</code> onto the current branch you do
      <code><a name="gl-merge">gl merge my-branch</a></code>,
      for rebasing the current branch using as a base <code>my-branch</code> you do
      <code><a name="gl-rebase">gl rebase my-branch</a></code>.
      </p>
      <p>
      During this process conflicts could occur. If so, the <code>gl status</code> command will change
      accordingly to indicate the files in conflict. Once you edit those files in
      conflict you mark them as resolved with
      <code><a name="gl-resolve">gl resolve</a></code> (passing the files to mark as input). Once all
      conflicts have been resolved
      you do <code>gl commit</code> to commit the merge commit in
      case of a merge or to continue applying any remaining commits in case of
      a rebase.
      </p>
      <p>
      Of course, it is also possible to merge or rebase changes from remote
      branches, or branches that are in remote repositories (not in your local
      repository). Let's say "experiment" stands for the remote at 
      https://github.com/spderosso/experiment.git and that master is a branch
      present in that remote repository. If so, doing
      <code>gl merge experiment/master</code>
      would merge any changes in that remote branch that are not present in your
      local current branch. A very common use case is to have a remote
      repository you always get changes from and send changes to it so that
      others can retrieve them. To make this more easy, a branch can have an
      "upstream branch". If a branch has an upstream associated with it, then
      <code>gl rebase</code> or <code>gl merge</code> can be used as shorthands for
      <code>gl {rebase, merge} upstream_remote/upstream_branch</code>. To set an
      upstream branch for the current branch use
      <code>gl branch -su upstream_remote/upstream_branch</code>.
      </p>
      <p>
      To publish your changes to this upstream branch you can do
      <code><a name="gl-publish">gl publish</a></code>. If the upstream
      branch doesn't exist in the remote, then the branch will be created in the
      remote after the publish.
      </p>
      <p>
      When you create a local repository from a remote (by passing a url as
      input to the <code>gl init</code> command), all branches are
      automatically configured to have as upstream their remote counterpart.
      </p>
  
      <a name="remote"><h4>Remote</h4></a>
      <p>
      You can always use the direct url to
      bring in changes to your local repository from a remote repository but
      remembering all those long urls can be annoying. So an easier way is to
      add that repository as a "remote" with the
      <code><a name="gl-remote">gl remote</a></code> command.
      For example, let's add my Github experiment repository as a remote:
      </p>
      <pre>
      $ gl remote experiment https://github.com/spderosso/experiment.git
      # Remote experiment mapping to https://github.com/spderosso/experiment.git created successfully
      #   (to list existing remotes do gl remote)
      #   (to remove experiment do gl remote -d experiment)
      </pre>
      <p>
      And then you can use experiment/branch as a shorthand for referring to a
      branch in the experiment repository.
      </p>
      <!-- End Documentation/Guide -->
    </div>
    <!-- End Documentation -->

    <!-- Begin Community -->
    <div class="twothird">
      <h2>Community</h2>
      <p>
      Questions or comments to the Gitless's community can be sent to the
      <a href="https://groups.google.com/forum/#!forum/gl-users">Gitless
      users mailing list</a> on Google groups. For bug reports or feature
      requests you can
      <a href="http://github.com/sdg-mit/gitless/issues">create an issue
      on Github</a>.
      </p>
      <p>
      If you would like to contribute to the development of Gitless, you can
      read more about how you can help
      <a href="http://github.com/sdg-mit/gitless/blob/master/README.md">here</a>.
      </p>
    </div>
    <!-- End Community -->

    <!-- Begin Footer -->
    <div id="footer" class="full top_margin_20">
      <p>
      &copy; 2013 Santiago Perez De Rosso, Software Design Group at MIT.
      </p>
      <p>
      Gitless is part of a research project exploring concept design. This
      research is part of a collaboration between MIT and SUTD (the
      Singapore University of Technology and Design), and is funded by a grant
      from SUTD's International Design Center.
      </p>
    </div>
    <!-- End Footer -->
  </div>
</body>
</html>
